# 浏览器在输入URL地址后到看到页面，都经历了什么?

## 1、URL解析

### 1）地址解析

```javascript
// 例：
http://user:pass@www.aaa.com:8080/index.html?a=1&b=2#c
```

- `http`：协议（如 `http`、`https`、`ftp` 、...）

  > 传输协议：用于传输客户端和服务器端通信的信息
  >
  > + `HTTP`：超文本(除文本外的富媒体资源，例如：图片、视频等)传输协议
  > + `HTTPS`：`HTTP+SSL`(加密传输) ，支付类网站基本上都是基于`HTTPS`传输协议处理的
  > + `FTP`：文件传输协议（现在一般用于客户端和服务器端文件的直接传输）

- `user:pass`：登录信息（认证）

- `www.aaa.com`：域名（服务器地址）

- `8080`：端口号（0~65535）

  > 端口号：0~65535之间。（端口号就是用来区分同一台服务器上的不同项目的（`nginx`配置的时候设置））
  >
  > `HTTP`：默认 80。自己写地址的时候，如果不加端口号，浏览器或按照默认端口号自动补充上（发给服务器的一定带着端口号）
  >
  > `HTTPS`：默认 443。
  >
  > `FTP`：默认 21。

- `index.html`：请求资源的文件路径

- `a=1&b=2`：查询字符串（问号参数）

- `c`：片段标识符：HASH值

### 2）编码

## 2、缓存检查

> 缓存位置有如下两种：
>
> - Memory Cache：内存缓存
> - Disk Cache：磁盘缓存

1）打开网页：查找 **硬盘缓存** 中是否有缓存的匹配的资源，如果有对应资源，则使用缓存资源即可，如果没有缓存资源，则需要发送网络请求请求相应资源。

2）普通刷新（`F5`）：因为浏览器页签没有关闭，所以 **内存缓存** 是可用的，会被优先使用，其次才是 **硬盘缓存**。

3）强制刷新（`Ctrl+F5`）：浏览器不使用缓存，所以发送的请求头部都会带有 `cache-control: no-cache`，服务器直接返回 200 和最新的内容。

### 客户端缓存处理

分为 **强缓存** 和 **协商缓存**，都是对资源文件的缓存处理（*对于数据的缓存**不是**这样处理*）

#### 强缓存

浏览器

##### Expires

缓存过期时间，用来指定资源到期的时间（HTTP/1.0）

##### Cache-Control

第一次拿到资源后的缓存时间(单位：秒-s)内再次发送请求请求资源，则读取缓存信息（HTTP/1.1）

> Cache-Control 优先级 高于 Expires

##### 请求与缓存

​		服务器设置的，并且基于响应头信息返回给客户端的（`nginx`这些发布工具直接搞定的）；客户端浏览器接收到响应后，会自己建立缓存机制（不需要前端写代码处理）。

- 第一次请求，没有缓存，直接从服务器获取（缓存标识`Expires/Cache-Control`），客户端获取到内容后，把信息和标识缓存到本地；
- 第二次请求，检测本地是否有缓存「检查是否过期」，如果没过期，则直接基于缓存信息渲染；如果没有或者过期，重复第一步；

> 无论是否走缓存，HTTP请求状态码都是200。

![image-20201208224729124](C:\Users\19234\AppData\Roaming\Typora\typora-user-images\image-20201208224729124.png)

##### 强缓存存在的问题

###### 问题

客户端缓存了资源信息，但是如果此时项目发布更新了服务器资源文件，访问者无法及时获取到服务器最新资源信息。

###### 如何解决

`.html`文件是不做强缓存的。

`.css`、`.js`、`.jpg` 等等资源是可以做强缓存处理，因为`html`没有做强缓存处理，所以每一次都是从服务器获取到的，只要有更新，就能够获取到最新的。所以我们可以在 `html` 文件中导入资源的时候处理。如：

- 在导入资源的路径后面加上时间戳
- 使用 `webpack` 的话，内容发生更改，会自动生成新的文件名（`hash值`）

#### 协商缓存

（客户端需要和服务器协商)：**在强缓存失效的情况下，协商缓存的机制才会触发**

##### Last-Modified/If-Modified-Since

项目部署文件时，生成的一个文件标识。表示当前项目文件在服务器上最后一次更新的时间或者对应的标识。

##### ETag/If-None-Match

项目部署文件时，生成的一个文件标识。表示当前项目文件在服务器上最后一次更新的时间或者对应的标识。

##### 请求与缓存

**前提： 没有强缓存或者强缓存失效**

- 第一次请求，没有任何缓存，直接从服务器获取资源和标识`Last-Modified/ETag`(状态码返回的是200)，页面渲染同时，存储到本地；

- ......

- 第N次请求，检测本地是否有存储的标识，如果没有认为没缓存，重复上一个步骤，如果有：

  + 基于标识If-Modified-Since/If-None-Match，把之前存储的 ` Last-Modified/ETag ` 结果，传递给服务器

  + 服务器收到结果做匹配

    + 服务器端一般这样处理的，在项目文件部署的时候，会生成 `Last-Modified/ETag` 对应的值，这个值代表当前项目文件在服务器上最后一次更新的时间或者对应的标识。

    + 接收到客户端传递的结果，和之前存储的值进行比较。

      1）如果一致说明文件没有更新，给客户端直接返回304状态码即可。

      2）如果不一致说明文件有更新，则把最新的文件信息及标识信息重新返回给客户端，状态码是200。

  + 客户端收到响应后，判断状态码

    + 304：把之前缓存的文件拿出来渲染
    + 200：按照最新的文件渲染，同时更新本地的缓存

![image-20201208225626321](C:\Users\19234\AppData\Roaming\Typora\typora-user-images\image-20201208225626321.png)

#### 资源缓存可采取的方案

`html` 文件可以采用协商缓存，其他的资源文件一般可选择设置**强缓存**与**协商缓存**两种缓存模式。



#### 数据缓存

把不经常更新的数据从服务器中获取到后，缓存下来。

##### 请求数据方式

`ajax：ajax/axios(promise)/JQ-ajax`、`fetch`、非同源的跨域请求等。

##### 存储方案

1. `cookie/localStorage/sessionStorage`
2. 本地数据库(浏览器数据库)存储 `IndexedDB`
3. `vuex/redux...`
4. ......



​		方案1 与方案2，都是把信息存储到本地(物理磁盘)，即使页面关闭重新打开，缓存的信息也存在（不含`sessionStorage`）。

​		方案3 类似于定义了全局变量存储信息，页面关闭或者刷新存储的信息都会消失，这种情况在SPA单页面应用，组件之间来回切换的时候可以用。



##### 请求与缓存实现步骤

- 第一次发送数据请求，本地没有任何的数据缓存(或者缓存周期已经过了)，我们基于`ajax`等从服务器获取数据；
- 在进行数据绑定的时候，同时把获取的数据存储到本地（存储的时候我们一般会自己手动设置过期时间）；
- 再次发送请求（例如:重新预览页面、刷新页面...），我们依然是查找本地是否缓存以及缓存是否过期，如果缓存生效的，则直接从缓存中获取数据进行渲染，反之重复前两步。

![image-20201208232055370](C:\Users\19234\AppData\Roaming\Typora\typora-user-images\image-20201208232055370.png)

##### 如何选择缓存方案

1. 如果需要存储的数据量特别大，则基于`IndexedDB`是一个不错的选择（`localStorage`一个源下只能存储`5MB`）。

2. `localStorage ` 与`sessionStorage` 都是`H5`新的`API`（不兼容`IE6~8`）

   `localStorage`持久存储，而`sessionStorage`是会话存储，只要页面关闭，则存储的信息就没有了。

3. `localStorage`  与 `cookie`：

   - 存储大小，同源下`localStorage`最多存储`5MB`，而cookie只能存储`4KB`左右
   - 稳定性：`cookie`有过期时间，而且清除浏览器或者电脑记录或者垃圾，都有可能会把他清除掉，并且浏览器的无痕浏览器模式是无法记录`cookie`的。`localStorage`是持久存储，基本上只要不是手动清除会一直存在。
   - 和服务器关系：`localStorage`和服务器没有任何的关系（当然你可以自己手动把`localStorage`中存储的信息发送给服务器），但是`cookie`不行，只要本地有`cookie`，在向服务器发送请求的时候，浏览器都会把这些信息发送给服务器。
   - `cookie`的好处是兼容，某些需要在每次请求的时候，把信息传递给服务器的，可以存储到`cookie`中。

4. `vuex/redux` 在SPA单页面应用，组件之间来回切换的时候可以用。

## 3、DNS解析

`DNS` 分为两大类查询

- 递归查询
- 迭代查询

查看本地缓存的解析记录。使用递归的方式。如果本地没有缓存，按照迭代的方式查找`DNS`解析记录（重新解析）。

> 有缓存，速度会很快。

第一次请求，从来没有解析过，需要20-120 ms左右从头解析，第一次请求完之后，当前的`DNS`解析记录浏览器会默认缓存下来。第二次请求就会去递归查询（查看本地是否有缓存）或者迭代查询（如果本地没有缓存，重新解析）。

### 递归查询

依次查找浏览器缓存、本地`host`、本地`DNS`解析器、本地`DNS`服务器。如果有缓存，就在这其中的一个，使用缓存即可，不需要再去`DNS`服务器上查找。

![image-20201208235049904](C:\Users\19234\AppData\Roaming\Typora\typora-user-images\image-20201208235049904.png)



### 迭代查询



![image-20201208235558878](C:\Users\19234\AppData\Roaming\Typora\typora-user-images\image-20201208235558878.png)

通过完整的迭代查询获取到主机`IP`

浏览器通过`IP`向服务器发起请求。



### DNS解析优化

每一次`DNS`解析时间约为 20-120 ms。优化方式

- 减少`DNS`请求次数
- `DNS `预获取

```html
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href=""/>
<link rel="dns-prefetch" href=""/>
```



> `DNS`优化 

- 一个产品，我们尽可能少去请求不同的不服务/域名(减少`DNS`的解析次数) 「这是一个被舍弃的方案」

- `DNS`预解析 （`dns-prefetch`）：利用link的异步加载，在GUI线程渲染页面的同时，去实现`DNS`解析，当GUI渲染到某部分，需要请求外部资源，但是此时我们已经解析过了，不用此时再去从新解析...

> 当代产品的开发，资源一般都是部署到不同的服务器上（尤其是大项目）
>
> 服务器拆分优势：资源合理利用、抗压能力加强、提高HTTP并发等等

- web资源服务器 `nginx/apache/iis`... （`html/css/js`...）

- 图片资源服务器 （`img`...）

- 数据接口服务器 （后台程序、数据库...）

- 第三方服务器器

- ...

> 弊端

- 增加了`DNS`解析的时间

> 优势：

- 合理的服务器资源分配 & 提高并发（每一台服务器的并发是有上限的）

- 每一个源下，可以同时允许的HTTP并发数6~7个，也是有助于页面渲染速度的

- ...

## 4、TCP三次握手

> TCP：客户端和服务器之间的网络传输通道。（HTTP在这个通道上传递数据等信息）
>
> 三次握手：建立客户端与服务器子件的连接通道。

`UDP` 不稳定，没有三次握手这样的机制。但是速度快。

`TCP` 是稳定可靠的通信协议，也是最常用的，但是速度慢。（核心思想：既要保证数据可靠传输，又要提高传输的效率）



如下图所示：

>- `seq`序号，用来标识从`TCP`源端向目的端发送的字节流，发起方发送数据时对此进行标记
>- `ack`确认序号，只有`ACK`标志位为1时，确认序号字段才有效，`ack`=`seq`+1
>- 标志位
>  + `ACK`：确认序号有效
>  + `RST`：重置连接
>  + `SYN`：发起一个新连接
>  + `FIN`：释放一个连接
>  + ......

![image-20201209203414055](C:\Users\19234\AppData\Roaming\Typora\typora-user-images\image-20201209203414055.png)

`TCP` 三次握手后，客户端基于 `HTTP` 把数据传递给服务器，同时发起 `TCP` 四次挥手。



## 5、数据传输

### HTTP报文

所有客户的和服务器端传输的信息统称为“报文”

> 请求：客户端传递给服务器
>
> 响应：服务端返回给客户端的信息

- 起始行：请求起始行、响应起始行
- 首部（头）：通用头、请求头、响应头、自定义头信息

- 主体：请求主体、响应主体



​		服务器给客户端返回的信息，大部分都是放在响应主体中的，只有少部分是基于响应头返回的，而且响应头先返回，间隔一段时间响应主体才返回。

​		客户端传递给服务器的信息，一部分是基于请求头传递的，还有一部分还是基于请求主体（例如：POST请求方式下的AJAX/FETCH），也可以直接拼接到`url`末尾，基于问号参数传递（例如：GET请求下的AJAX/FETCH）

​		HTTP事物：每完成一次请求+响应，算一次完整的HTTP事物

​		客户的和服务器通信的时候，会默认在请求头中把客户端存储的cookie信息传递给服务器

### Ajax

> `async javascript and xml` ：异步的`JS`和`XML`
>
> 原理：`XMLHttpRequest`（IE低版本浏览器使用的是：`ActiveXObject`）

```
	早期，客户端和服务器端的数据通信，都是基于XML格式的数据完成的；当代，两端之间的数据通信，都是基于更强大的JSON等格式数据来完成(更小、操作更方便)。
	async javascript：这里不是指的以后发送ajax请求都采用异步，而是代表“浏览器的异步(局部)刷新（前后端分离）”[浏览器的全局刷新（服务器渲染）]
```



请求基础配置：

- 请求方式（method）：
  + GET： GET/DELETE/HEAD/OPTIONS
  + POST： POST/PUT/PATCH
- `url `：请求地址
- `async`：是否采用异步编程，默认TRUE。一般都采用异步编程，以防止同步下，当数据请求超时，其余事情无法处理的问题（避免阻塞）。
- ...

**GET 和 POST 的区别：**

​		项目中，GET一般用于从服务器获取信息（给服务器的少，从服务器拿的多），POST一般用于给服务器推送信息（给服务器的多，从服务器端获取的少）。

>以下区别非官方规范，而是平时项目约定规范：
>
>- GET系利请求，传递给服务器的信息是基于URL问号参数完成的，而POST是基于请求主体完成的「当然都可以设置请求头，携带部分信息」
>- 浏览器对于URL地址的长度是有限制的(IE大概是2KB)，所以GET请求，传递给服务器的信息不能多，但是POST基于请求主体传递信息，理论上是没有长度限制的，但是实际中为了保证速度，我们需要自己手动限制
>- GET系列请求非常容易产生不可控制的缓存「如果两次请求的地址、参数等信息一致，则很有可能第二次请求获取的还是第一次请求的结果」，而POST则不会。 解决办法：让每一次GET请求的地址，保持唯一性，可以在请求中增加时间戳参数
>- GET相对POST来讲是不安全的；类似于URL劫持等低端手段，都可以把GET传递的信息进行肆意的获取或者修改

监听请求的状态和阶段，获取到服务器返回的信息：

- `readyState` : AJAX请求状态
  + 0: UNSENT 最开始
  + 1: OPENED 已经执行open方法了
  + 2: HEADERS_RECEIVED 服务器已经返回了响应头信息
  + 3: LOADING 响应主体信息正在处理和返回
  + 4: DONE 响应主体信息已经获取，此时证明AJAX请求结束了

+ 服务器返回的HTTP状态码

  + 200: OK 成功
  + 202 Accepted ：服务器已接受请求，但尚未处理（异步）
  + 204 No Content：服务器成功处理了请求，但不需要返回任何实体内容
  + 206 Partial Content：服务器已经成功处理了部分 GET 请求（断点续传 Range/If-Range/Content-Range/Content-Type:”multipart/byteranges”/Content-Length….）
  + 301 Moved Permanently
  + 302 Move Temporarily
  + 304 Not Modified
  + 305 Use Proxy
  + 400 Bad Request : 请求参数有误
  + 401 Unauthorized：权限（Authorization）
  + 404 Not Found
  + 403 一切访问正常，但是服务器就是不让获取任何信息
  + 405 Method Not Allowed
  + 408 Request Timeout
  + 500 Internal Server Error
  + 503 Service Unavailable
  + 505 HTTP Version Not Supported
  + ……

+ 发送数据请求的数据格式（请求头中的 Content-Type）

  > send中存方的是基于请求主体传递给服务器的信息

  + form-data 表单提交/文件上传(选取的文件)  `MIME -> multipart/form-data`
  + `x-www-form-urlencoded` （项目中很常用，因为和GET请求下，问号参数的形式是一致的，很多后台都要求我们传递这样格式的字符串） `MIME -> application/x-www-form-urlencoded`
  + raw: `Text/JSON/XML...` 文本字符串 `MIME -> text/plain application/json application/xml...`
  + binary 二进制/字节流 MIME -> 根据选取文件的类型，有自己对应不同的MIME，例如：`image/jpeg `或者 `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`
  + `GraphQL`
  + ...

```javascript

let xhr = new XMLHttpRequest;
xhr.open('GET', '/');
xhr.onreadystatechange = function () {
    if (xhr.status !== 200) return;
    if (xhr.readyState === 4) {
        // 获取的结果一般都是JSON格式字符串
        console.log(xhr.getResponseHeader('date'));
        console.log(xhr.responseText);
    }
};
xhr.send(null);

// ------请求的数据格式--------
xhr.setRequestHeader('Content-Type', 'multipart/form-data');
let formData = new FormData;
formData.append('aaa', 'ccc');
formData.append('bbb', 1);
xhr.send(formData);

// ------请求的数据格式--------
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
// Qs：实现对象和x-www-form-urlencoded格式字符串之间的转换（和内置JSON不一样）
xhr.send(Qs.stringify({
    account: '123456',
    password: md5('888888')
}));

// ------设置请求头--------
// 设置请求头：必须在OPENED之后，而且内容不能出现中文和特殊符号
xhr.setRequestHeader('aaa', encodeURIComponent('中文字符串'));

// ------设置请求超时时间------
xhr.timeout = 1;
xhr.ontimeout = function () {
    console.log('请求超时');
};

// --在CORS跨域请求中是否允许携带资源凭证(例如:cookie) 默认false--
xhr.withCredentials = true;

// ---------监听上传进度：做进度条--------
xhr.upload.onprogress = function () {};

```



## 6、TCP四次挥手

> 四次挥手：
>
> 1. 服务器拿到 HTTP 传输的数据信息以及关闭通道信息;
> 2. 处理客户端的请求并应答，立即准备客户端需要的数据;
> 3. 把处理好的数据返回给客户端，告知客户端接收数据并关闭通道；
> 4. 客户端获取到数据后，给服务器应答。



**TCP连接的时候三次握手，而关闭的时候四次挥手的原因：**

​		服务器接收到客户端的请求后，需要立即给客户端一个响应，同时准备客户端需要的数据。如果不立即给客户端响应，客户端此时无法知道服务器是否接收到客户端发起的请求。（会导致客户端由于不确定服务器是否收到请求，而一直去不停地发送请求）。只有在客户端需要的数据准备完成后，将数据与通道关闭信息一起发送给客户端。



> 每一次客户端和服务器的请求，都需要TCP的三次握手和四次挥手。都需要消耗一定的时间。

如图所示：

![image-20201209204735732](C:\Users\19234\AppData\Roaming\Typora\typora-user-images\image-20201209204735732.png)



## 7、页面渲染

​		客户端从服务器获取到需要渲染页面的源代码后，会开辟一个【GUI渲染线程】，自上而下解析代码，最后才绘制出对应的界面。自上而下渲染解析代码的过程是“同步”的，但是有些操作也是异步的。

> `Webkit`浏览器预测解析：chrome的预加载扫描器`html-preload-scanner`通过扫描节点中的 `src`, `link`等属性，找到外部连接资源后进行预加载，避免了资源加载的等待时间，同样实现了提前加载以及加载和执行分离。



### CSS 资源加载

#### `<style> ` 内嵌样式

> 同步
>
> GUI渲染线程解析

#### `<link>` 外链样式

>异步
>
>开辟一个新的“HTTP网络请求线程” （同一个源下，根据不同的浏览器，最多只允许同时开辟4～7个HTTP线程 “HTTP的并发数”）
>
>- 不等待资源信息请求回来，GUI渲染线程继续向下渲染
>- GUI渲染线程同步操作都处理完成后，再把基于HTTP图片络线程请求回来的资源文件进行解析渲染

#### `@import` 导入式样式

>同步
>
>开辟一个新的“HTTP网络请求线程”去请求资源文件
>
>在资源文件没有请求回来之前，GUI渲染线程会被“阻塞”，不允许其继续向下渲染

### script 资源请求

> 默认都是 **同步** 的
>
> 必须基于HTTP网络线程，把资源请求回来之后，并且交给“`JS`渲染线程”渲染解析完成后，GUI渲染线程才能继续向下渲染，所以`<script>`默认也是“阻碍GUI渲染”的。

#### async 属性

> 遇到`<script async>`首先也是开辟一个HTTP网络线程去请求加载资源文件。
>
> 同时GUI渲染线程继续向下渲染「把默认的同步改为“异步”」，但是一旦当资源请求回来后，会中断GUI的渲染，先把请求回来的`JS`进行渲染解析。

#### defer属性

> 遇到`<script defer> `和`async`类似，都是新开辟HTTP网络线程去请求加载资源文件。
>
> 同时GUI还会继续渲染「“异步”」，但是不一样的地方是，defer和link类似，是在GUI同步的代码渲染完成后，才会渲染解析请求回来的`JS`代码。



### 图片音视频等资源请求

> 遇到这些资源，也会发送新的HTTP网络线程，请求加载对应的资源文件，不会阻碍GUI的渲染「“异步”」。
>
> 当GUI渲染完成后，才会把请求回来资源信息进行渲染解析。



### 页面渲染步骤

1. `DOM TREE`（`DOM`树）：自上而下渲染完页面，整理好整个页面的`DOM`结构关系
2. `CSSOM TREE`（样式树）：当把所有的样式资源请求加载回来后，按照引入`CSS`的顺序，依次渲染样式代码，生成样式树
3. `RENDER TREE`（渲染树）：把生成的`DOM`树和`CSSOM`树合并在一起，生成渲染树（设置`display:none`的元素不进行处理）
4. `Layout ` 布局/回流/重排： 根据生成的渲染树，计算它们在设备视口(`viewport`)内的确切位置和大小
5. 分层处理：按照层级定位分层处理，每一个层级都有会详细规划出具体的绘制步骤
6. `Painting`：按照每一个层级计算处理的绘制步骤，开始绘制页面



# HTTP

## HTTP1.0、HTTP1.1、HTTP2.0比较

### HTTP1.0 与 HTTP1.1 的区别

- **缓存处理**：`HTTP1.0`中主要使用 Last-Modified，Expires 来做为缓存判断的标准，`HTTP1.1`则引入了更多的缓存控制策略：`ETag`，Cache-Control…
- **带宽优化及网络连接的使用**：`HTTP1.1`支持断点续传，即返回码是206（Partial Content）
- **错误通知的管理**：在`HTTP1.1`中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…
- **Host头处理**：在`HTTP1.0`中认为每台服务器都绑定一个唯一的`IP`地址，因此，请求消息中的URL并没有传递主机名（`hostname`）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个`IP`地址。`HTTP1.1`的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）
- **长连接**：`HTTP1.1`中默认开启Connection： keep-alive，一定程度上弥补了`HTTP1.0`每次请求都要创建连接的缺点

### HTTP2.0 与 HTTP1.1/1.0 的区别

- **新的二进制格式（Binary Format）**：`HTTP1.x`的解析是基于文本，基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合，基于这种考虑`HTTP2.0`的协议解析决定采用二进制格式，实现方便且健壮。
- **header压缩**：`HTTP1.x`的header带有大量信息，而且每次都要重复发送，`HTTP2.0`使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
- **服务端推送（server push）**：客户端收到一个资源的时候，服务器主动推送另一个相应的资源到客户端，客户端去尝试获取这个资源的时候，就可以冲缓存中获取到，不用再次发起请求。
- **多路复用（`MultiPlexing`）**：
  + HTTP/1.0  每次请求响应，建立一个TCP连接，用完关闭。
  + （长连接）若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞。
  + （多路复用）多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行。



# 基于网页渲染的性能优化方案

## 生成DOM TREE

- 减少DOM的层级嵌套
- 不要使用“非标准”的标签
- ...

## 生成`CSSOM`

- 尽可能不要使用@import（阻塞GUI渲染）
- 如果`CSS`代码比较少，尽可能使用“style内嵌样式”（尤其是移动端开发）
- 如果使用link，尽可能把所有的样式资源合并为一个，且压缩（减少HTTP请求数量，因为HTTP的并发性也是有限制的，以及渲染`CSS`的时候，也不需要再计算依赖关系...）
- `CSS`选择器链短一些（因为`CSS`选择器渲染是从右到左的）
- 把link等导入`CSS`的操作放在HEAD中（目的是：一加载页面就开始请求资源，同时GUI去生成DOM树 “`CSS`等资源预先加载”）
- ...

## 其他资源的优化

- 对于`<script>`，尽可能放置在页面的底部（防止其阻塞GUI的渲染）；对于部分`<script>`需要使用`async`或者`defer`；
  + `async`是不管`JS`的依赖关系的，哪一个资源先获取到，就先把这个资源代码渲染执行
  + defer不会这样的，和link一样，是等待所有`<script defer>`都请求回来后，按照导入顺序/依赖关系依次渲染执行的
- 对于`<img>`
  + 懒加载：第一次加载页面的时候不要加载请求图片，哪怕它是异步的，但是也占据了HTTP并发的数量，导致其他资源延后加载
  + 图片的`BASE64`：不用去请求加载图片，`BASE64`码基本上代表的就是图片，而且页面渲染图片的时候速度也会很快（慎用，但是在`webpack`工程化中可以使用，因为它基于file-loader可以自动`base64`）
- ...

## Layout/Painting：重要的优化手段（减少DOM的“回流/重排”和重绘）

- 第一次加载页面必然会有一次回流和重绘

- 触发回流操作后，也必然绘触发重绘；如果只是单纯的重绘，则不会引发回流；性能优化点，重点都在回流上；

  + 导致回流的操作（这些操作都需要浏览器重新计算每一个元素在视口中的位置和大小（也就是重新`Layout`/`Reflow`））

    + 元素在视口中的大小或者位置发生变化
    + 元素的删除或者新增（以及基于display控制显示隐藏）
    + 浏览器视口大小发生改变
    + ...

    > 当代浏览的渲染队列机制：在当前上下文操作中，遇到一行修改样式的代码，并没有立即通知浏览器渲染，而是把其放置在渲染队列中，接下来看是否还有修改样式的代码，如果有继续放置在渲染队列中。一直到再也没有修改样式的代码或者“遇到一行获取样式的操作”，这样都会刷新浏览器的渲染队列机制（也就是把现在队列中修改样式的操作，统一告诉浏览器渲染，这样只会引发一次回流）。
    >
    > 
    >
    > `ele.style.attr` 或者 `window.getComputedStyle(ele).attr` 再或者 `ele.clientWidth|Height|Top|Left` 以及 `ele.offsetWidth|Height|Top|Left` 或者 `ele.scrollWidth|Height|Top|Left` ...这些获取样式的操作都会刷新渲染队列。
    >
    > 
    >
    > **优化方案**：
    >
    > 1. 不要自己直接去操作DOM，例如`vue/react`（只操作数据，让框架帮我们根据数据渲染视图（框架内部本身对于DOM的回流和重绘以及其它性能优化做的非常好））
    > 2. 样式的“分离读写”：把修改样式和获取样式代码分离开
    > 3. 新增元素时，先处理好所有的元素，再一次性添加到页面中。（如使用模板字符串或者文档碎片`document.createDocumentFragment()`）
    > 4. 把动画等频发样式改变的操纵，运用到`position:fixed/absolute`...上。（脱离文档流：单独一层）
    >    + 利用分层机制，如果只改变一个层面上的位置大小等信息，浏览器回流和重绘的速度会加快很多
    > 5. 修改元素的 `transform / opacity（filters）`... 的这些样式，不会引发DOM的回流（浏览器的硬件加速，弊端就是消耗浏览器的内存，性能消耗严重，有时候会导致字体模糊等）
    > 6. 牺牲平滑度换取速度：每次1像素移动一个动画，但是如果此动画使用了100%的CPU，动画就会看上去是跳动的，因为浏览器正在与回流做东征。每次移动3像素可能开起来平滑度低了，但它不会导致CPU在较慢的机器中抖动
    > 7. 避免 table 布局和使用 `css `的`JavaScript`表达式

## 利用缓存

- 对于静态资源文件实现强缓存和协商缓存（扩展：文件有更新，如何保证及时刷新？）
- 对于不经常更新的接口数据采用本地存储做数据缓存

## DNS优化

- 分服务器部署，增加HTTP并发性（导致`DNS`解析变慢）
- `DNS Prefetch`

## TCP的三次握手和四次挥手

- `Connection:keep-alive`

## 数据传输

- 减少数据传输的大小
  + 内容或者数据压缩（`webpack`等）
  + 服务器端一定要开启`GZIP`压缩（一般能压缩60%左右）
  + 大批量数据分批次请求（例如：下拉刷新或者分页，保证首次加载请求数据少）
- 减少HTTP请求的次数
  + 资源文件合并处理
  + 字体图标
  + 雪碧图 `CSS-Sprit`
  + 图片的`BASE64`
- ...

## 其他

- `CDN`服务器“地域分布式”
- 采用`HTTP2.0`
- 图片懒加载
- 加载 `loading` 效果
- ...













